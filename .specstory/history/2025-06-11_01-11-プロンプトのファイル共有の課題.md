<!-- Generated by SpecStory -->

# プロンプトのファイル共有の課題 (2025-06-11 10:11:13)

_**User**_

あなたの機能について質問です。私は@about-this-project.md にあるように、プロンプトを保存し簡単に使えるようにする拡張機能を作成しています。
この拡張機能の技術的課題として、ファイルの共有をどのように行うか、というのがあります。
あなた（Cursor）に対してファイルの共有を行うのは簡単です。@を使えばよいです。が、それはプロンプトを位置から手で入力した場合の話で、既存のプロンプトをコピーペーストする場合は話が違います。既存のプロンプト内に参照したいファイルの情報を@付きで記載したとしても、それがあなたに「ファイル名である」と解釈されることはありません。この問題を解決するには、どのような手段があるでしょうか。

---

_**Assistant**_



---

この技術的課題について、いくつかの解決方法をご提案します。

## 解決方法

### 1. **ファイル内容の事前埋め込み方式**
プロンプトテンプレート内の`@ファイル名`を、拡張機能側で実際のファイル内容に置換してからCursorに送信する方法です。

```
# テンプレート保存時
「@src/utils.js の関数を参考にして...」

# 実行時に変換
「```js
// src/utils.js の内容がここに埋め込まれる
function example() { ... }
```
の関数を参考にして...」
```

### 2. **相対パス形式での埋め込み**
`@`ではなく、特殊な記法（例：`{{file:パス}}`）を使い、拡張機能側でファイル内容を読み込んで置換する方式：

```
# テンプレート
「{{file:src/components/Button.tsx}} を参考にして新しいコンポーネントを作成してください」

# 実行時
「```tsx
// Button.tsx の実際の内容
export const Button = () => { ... }
```
を参考にして新しいコンポーネントを作成してください」
```

### 3. **VS Code APIの活用**
VS Code の `vscode.workspace.openTextDocument()` APIを使用してファイル内容を取得し、プロンプトに埋め込む：

```typescript
// 拡張機能内の処理例
async function processPromptTemplate(template: string): Promise<string> {
    const filePattern = /@([^\s]+)/g;
    let processedTemplate = template;
    
    const matches = template.match(filePattern);
    if (matches) {
        for (const match of matches) {
            const filePath = match.substring(1); // @ を除去
            try {
                const document = await vscode.workspace.openTextDocument(filePath);
                const fileContent = document.getText();
                processedTemplate = processedTemplate.replace(
                    match, 
                    `\`\`\`${filePath}\n${fileContent}\n\`\`\``
                );
            } catch (error) {
                // ファイルが見つからない場合の処理
            }
        }
    }
    
    return processedTemplate;
}
```

### 4. **ハイブリッド方式**
- 存在するファイルは内容を埋め込み
- 存在しないファイルは警告メッセージを表示
- ユーザーが選択可能（埋め込みするか、@参照のままにするか）

## 推奨アプローチ

**方法2（特殊記法での埋め込み）** をお勧めします。理由：

1. `@`記法と区別できるため、意図が明確
2. ファイルサイズが大きい場合も制御しやすい
3. エラーハンドリングが容易
4. ユーザーが明示的にファイル埋め込みを指定できる

この方式なら、プロンプトテンプレート実行時に確実にファイル内容がCursorに渡され、AIが適切にファイルを認識できるようになります。

---

_**User**_

そのような埋め込みだと、あなた方に普段渡されているプロンプトの形式と異なりますがそれは大丈夫ですか？
Cursorは<file_contents>といったXMLタグで囲われたファイル内容を参照しているようですが

---

_**Assistant**_



---

おっしゃる通りです！非常に重要なポイントをご指摘いただきました。

Cursorは確かに特定のXML形式でファイル内容を受け取っており、単純なマークダウンのコードブロックでは適切に認識されない可能性があります。

## Cursorが期待する形式

現在の私への入力も以下の形式になっています：

```xml
<attached_files>
<file_contents>
```path=設計/about-this-project.md, lines=ALL(1-62)
# プロジェクト説明
...
```
</file_contents>
</attached_files>
```

## 正しい解決方法

拡張機能では、以下の形式でファイル内容を埋め込むべきです：

```typescript
async function processPromptTemplate(template: string): Promise<string> {
    const filePattern = /@([^\s]+)/g;
    let processedTemplate = template;
    let attachedFiles = '';
    
    const matches = template.match(filePattern);
    if (matches) {
        const fileContents: string[] = [];
        
        for (const match of matches) {
            const filePath = match.substring(1);
            try {
                const document = await vscode.workspace.openTextDocument(filePath);
                const content = document.getText();
                
                fileContents.push(`<file_contents>
\`\`\`path=${filePath}, lines=ALL(1-${document.lineCount})
${content}
\`\`\`
</file_contents>`);
                
                // 元の@参照を削除
                processedTemplate = processedTemplate.replace(match, '');
            } catch (error) {
                console.error(`ファイルが見つかりません: ${filePath}`);
            }
        }
        
        if (fileContents.length > 0) {
            attachedFiles = `<attached_files>
${fileContents.join('\n')}
</attached_files>

`;
        }
    }
    
    return attachedFiles + processedTemplate;
}
```

## 結果例

```xml
<attached_files>
<file_contents>
```path=src/utils.js, lines=ALL(1-50)
export function formatDate(date) {
    return date.toISOString();
}
```
</file_contents>
</attached_files>

このutils.jsの関数を参考にして、新しい日付処理関数を作成してください。
```

この形式なら、Cursorのシステムが適切にファイル内容を認識し、AIが正確にファイルを参照できるようになります。ご指摘いただき、ありがとうございました！

---

_**User**_

このように埋め込んだとして、実際の形式は下記のようになりますが、それでも大丈夫ですか？

<user_query>
   <attached_files>
        <file_contents>
        </file_contents>
   </attached_files>
</user_query>

---

_**Assistant**_



---

その構造だと問題が生じる可能性があります。

## 問題点

通常、Cursorが受け取る正しい構造は：

```xml
<attached_files>
    <file_contents>
    ...
    </file_contents>
</attached_files>

<user_query>
    ユーザーのプロンプト内容
</user_query>
```

しかし、拡張機能から送信される場合は：

```xml
<user_query>
    <attached_files>
        <file_contents>
        ...
        </file_contents>
    </attached_files>
    ユーザーのプロンプト内容
</user_query>
```

となり、XML構造が期待されるものと異なります。

## 代替解決策

### 1. **シンプルなマークダウン形式**
Cursorが認識しやすい形式でファイル内容を埋め込む：

```typescript
async function processPromptTemplate(template: string): Promise<string> {
    // @ファイル名 を以下の形式に置換
    const replacement = `
## File: ${filePath}
\`\`\`${getFileExtension(filePath)}
${fileContent}
\`\`\`
`;
    return processedTemplate;
}
```

### 2. **ファイル参照の明示化**
```typescript
const replacement = `
[添付ファイル: ${filePath}]
\`\`\`${getFileExtension(filePath)}
${fileContent}
\`\`\`
`;
```

### 3. **VS Code拡張機能のAPI制約を確認**
Cursor拡張機能のAPIドキュメントで、ファイル添付の正しい方法があるか確認することをお勧めします。

実際のところ、**方法1のシンプルなマークダウン形式**が最も安全で確実に動作すると思われます。AIは文脈からファイル内容を理解できるため、特殊なXMLタグは必須ではありません。

---

